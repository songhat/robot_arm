/*
 * Module code.
 *
 * Generated by SIP 4.19.21
 */

#include "sipAPIPyKDL.h"

#line 508 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolverpos_nr_jl.hpp>
using namespace KDL;
#line 13 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"

#line 241 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 18 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"
#line 280 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 22 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"
#line 428 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainfksolver.hpp>
using namespace KDL;
#line 26 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"
#line 482 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolver.hpp>
using namespace KDL;
#line 30 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"
#line 201 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 36 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"


class sipChainIkSolverPos_NR_JL : public  ::ChainIkSolverPos_NR_JL
{
public:
    sipChainIkSolverPos_NR_JL(const  ::Chain&,const  ::JntArray&,const  ::JntArray&, ::ChainFkSolverPos&, ::ChainIkSolverVel&,uint,double);
    sipChainIkSolverPos_NR_JL(const  ::ChainIkSolverPos_NR_JL&);
    virtual ~sipChainIkSolverPos_NR_JL();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures() SIP_OVERRIDE;
    int CartToJnt(const  ::JntArray&,const  ::Frame&, ::JntArray&) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverPos_NR_JL(const sipChainIkSolverPos_NR_JL &);
    sipChainIkSolverPos_NR_JL &operator = (const sipChainIkSolverPos_NR_JL &);

    char sipPyMethods[2];
};

sipChainIkSolverPos_NR_JL::sipChainIkSolverPos_NR_JL(const  ::Chain& a0,const  ::JntArray& a1,const  ::JntArray& a2, ::ChainFkSolverPos& a3, ::ChainIkSolverVel& a4,uint a5,double a6):  ::ChainIkSolverPos_NR_JL(a0,a1,a2,a3,a4,a5,a6), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos_NR_JL::sipChainIkSolverPos_NR_JL(const  ::ChainIkSolverPos_NR_JL& a0):  ::ChainIkSolverPos_NR_JL(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos_NR_JL::~sipChainIkSolverPos_NR_JL()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

void sipChainIkSolverPos_NR_JL::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainIkSolverPos_NR_JL::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverPos_NR_JL::CartToJnt(const  ::JntArray& a0,const  ::Frame& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_CartToJnt);

    if (!sipMeth)
        return  ::ChainIkSolverPos_NR_JL::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Frame&, ::JntArray&);

    return sipVH_PyKDL_5(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverPos_NR_JL_CartToJnt, "CartToJnt(self, q_init: JntArray, p_in: Frame, q_out: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverPos_NR_JL_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_NR_JL_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
        const  ::Frame* a1;
         ::JntArray* a2;
         ::ChainIkSolverPos_NR_JL *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_init,
            sipName_p_in,
            sipName_q_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverPos_NR_JL, &sipCpp, sipType_JntArray, &a0, sipType_Frame, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverPos_NR_JL::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos_NR_JL, sipName_CartToJnt, doc_ChainIkSolverPos_NR_JL_CartToJnt);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_ChainIkSolverPos_NR_JL_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverPos_NR_JL_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_NR_JL_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainIkSolverPos_NR_JL *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverPos_NR_JL, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainIkSolverPos_NR_JL::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos_NR_JL, sipName_updateInternalDataStructures, doc_ChainIkSolverPos_NR_JL_updateInternalDataStructures);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverPos_NR_JL(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverPos_NR_JL(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverPos_NR_JL *sipCpp = reinterpret_cast< ::ChainIkSolverPos_NR_JL *>(sipCppV);

    if (targetType == sipType_ChainIkSolverPos)
        return static_cast< ::ChainIkSolverPos *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverPos_NR_JL(void *, int);}
static void release_ChainIkSolverPos_NR_JL(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverPos_NR_JL *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverPos_NR_JL *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverPos_NR_JL(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverPos_NR_JL(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverPos_NR_JL *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverPos_NR_JL(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverPos_NR_JL(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverPos_NR_JL(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverPos_NR_JL *sipCpp = SIP_NULLPTR;

    {
        const  ::Chain* a0;
        const  ::JntArray* a1;
        const  ::JntArray* a2;
         ::ChainFkSolverPos* a3;
         ::ChainIkSolverVel* a4;
        uint a5 = 100;
        double a6 = epsilon;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_q_min,
            sipName_q_max,
            sipName_fksolver,
            sipName_iksolver,
            sipName_maxiter,
            sipName_eps,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9J9J9J9|ud", sipType_Chain, &a0, sipType_JntArray, &a1, sipType_JntArray, &a2, sipType_ChainFkSolverPos, &a3, sipType_ChainIkSolverVel, &a4, &a5, &a6))
        {
            sipCpp = new sipChainIkSolverPos_NR_JL(*a0,*a1,*a2,*a3,*a4,a5,a6);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverPos_NR_JL* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_ChainIkSolverPos_NR_JL, &a0))
        {
            sipCpp = new sipChainIkSolverPos_NR_JL(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverPos_NR_JL[] = {{8, 255, 1}};


static PyMethodDef methods_ChainIkSolverPos_NR_JL[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), SIP_MLMETH_CAST(meth_ChainIkSolverPos_NR_JL_CartToJnt), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_NR_JL_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverPos_NR_JL_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_NR_JL_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverPos_NR_JL, "\1ChainIkSolverPos_NR_JL(chain: Chain, q_min: JntArray, q_max: JntArray, fksolver: ChainFkSolverPos, iksolver: ChainIkSolverVel, maxiter: int = 100, eps: float = epsilon)\n"
"ChainIkSolverPos_NR_JL(ChainIkSolverPos_NR_JL)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverPos_NR_JL = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverPos_NR_JL,
        {SIP_NULLPTR},
        SIP_NULLPTR
    },
    {
        sipNameNr_ChainIkSolverPos_NR_JL,
        {0, 0, 1},
        2, methods_ChainIkSolverPos_NR_JL,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_ChainIkSolverPos_NR_JL,
    -1,
    -1,
    supers_ChainIkSolverPos_NR_JL,
    SIP_NULLPTR,
    init_type_ChainIkSolverPos_NR_JL,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_ChainIkSolverPos_NR_JL,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_ChainIkSolverPos_NR_JL,
    cast_ChainIkSolverPos_NR_JL,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 494 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolverpos_nr.hpp>
using namespace KDL;
#line 337 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"

#line 241 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 342 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"
#line 428 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainfksolver.hpp>
using namespace KDL;
#line 346 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"
#line 482 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolver.hpp>
using namespace KDL;
#line 350 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"
#line 280 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 354 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"
#line 201 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 360 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"


class sipChainIkSolverPos_NR : public  ::ChainIkSolverPos_NR
{
public:
    sipChainIkSolverPos_NR(const  ::Chain&, ::ChainFkSolverPos&, ::ChainIkSolverVel&,uint,double);
    sipChainIkSolverPos_NR(const  ::ChainIkSolverPos_NR&);
    virtual ~sipChainIkSolverPos_NR();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures() SIP_OVERRIDE;
    int CartToJnt(const  ::JntArray&,const  ::Frame&, ::JntArray&) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverPos_NR(const sipChainIkSolverPos_NR &);
    sipChainIkSolverPos_NR &operator = (const sipChainIkSolverPos_NR &);

    char sipPyMethods[2];
};

sipChainIkSolverPos_NR::sipChainIkSolverPos_NR(const  ::Chain& a0, ::ChainFkSolverPos& a1, ::ChainIkSolverVel& a2,uint a3,double a4):  ::ChainIkSolverPos_NR(a0,a1,a2,a3,a4), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos_NR::sipChainIkSolverPos_NR(const  ::ChainIkSolverPos_NR& a0):  ::ChainIkSolverPos_NR(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos_NR::~sipChainIkSolverPos_NR()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

void sipChainIkSolverPos_NR::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainIkSolverPos_NR::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverPos_NR::CartToJnt(const  ::JntArray& a0,const  ::Frame& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_CartToJnt);

    if (!sipMeth)
        return  ::ChainIkSolverPos_NR::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Frame&, ::JntArray&);

    return sipVH_PyKDL_5(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverPos_NR_CartToJnt, "CartToJnt(self, q_init: JntArray, p_in: Frame, q_out: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverPos_NR_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_NR_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
        const  ::Frame* a1;
         ::JntArray* a2;
         ::ChainIkSolverPos_NR *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_init,
            sipName_p_in,
            sipName_q_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverPos_NR, &sipCpp, sipType_JntArray, &a0, sipType_Frame, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverPos_NR::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos_NR, sipName_CartToJnt, doc_ChainIkSolverPos_NR_CartToJnt);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_ChainIkSolverPos_NR_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverPos_NR_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_NR_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainIkSolverPos_NR *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverPos_NR, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainIkSolverPos_NR::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos_NR, sipName_updateInternalDataStructures, doc_ChainIkSolverPos_NR_updateInternalDataStructures);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverPos_NR(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverPos_NR(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverPos_NR *sipCpp = reinterpret_cast< ::ChainIkSolverPos_NR *>(sipCppV);

    if (targetType == sipType_ChainIkSolverPos)
        return static_cast< ::ChainIkSolverPos *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverPos_NR(void *, int);}
static void release_ChainIkSolverPos_NR(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverPos_NR *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverPos_NR *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverPos_NR(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverPos_NR(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverPos_NR *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverPos_NR(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverPos_NR(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverPos_NR(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverPos_NR *sipCpp = SIP_NULLPTR;

    {
        const  ::Chain* a0;
         ::ChainFkSolverPos* a1;
         ::ChainIkSolverVel* a2;
        uint a3 = 100;
        double a4 = epsilon;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_fksolver,
            sipName_iksolver,
            sipName_maxiter,
            sipName_eps,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9J9|ud", sipType_Chain, &a0, sipType_ChainFkSolverPos, &a1, sipType_ChainIkSolverVel, &a2, &a3, &a4))
        {
            sipCpp = new sipChainIkSolverPos_NR(*a0,*a1,*a2,a3,a4);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverPos_NR* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_ChainIkSolverPos_NR, &a0))
        {
            sipCpp = new sipChainIkSolverPos_NR(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverPos_NR[] = {{8, 255, 1}};


static PyMethodDef methods_ChainIkSolverPos_NR[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), SIP_MLMETH_CAST(meth_ChainIkSolverPos_NR_CartToJnt), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_NR_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverPos_NR_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_NR_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverPos_NR, "\1ChainIkSolverPos_NR(chain: Chain, fksolver: ChainFkSolverPos, iksolver: ChainIkSolverVel, maxiter: int = 100, eps: float = epsilon)\n"
"ChainIkSolverPos_NR(ChainIkSolverPos_NR)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverPos_NR = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverPos_NR,
        {SIP_NULLPTR},
        SIP_NULLPTR
    },
    {
        sipNameNr_ChainIkSolverPos_NR,
        {0, 0, 1},
        2, methods_ChainIkSolverPos_NR,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_ChainIkSolverPos_NR,
    -1,
    -1,
    supers_ChainIkSolverPos_NR,
    SIP_NULLPTR,
    init_type_ChainIkSolverPos_NR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_ChainIkSolverPos_NR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_ChainIkSolverPos_NR,
    cast_ChainIkSolverPos_NR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 482 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolver.hpp>
using namespace KDL;
#line 657 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"

#line 280 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 662 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"
#line 281 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 668 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"
#line 159 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 672 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"
#line 331 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarrayvel.hpp>
using namespace KDL;
#line 676 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"


class sipChainIkSolverVel : public  ::ChainIkSolverVel
{
public:
    sipChainIkSolverVel();
    sipChainIkSolverVel(const  ::ChainIkSolverVel&);
    virtual ~sipChainIkSolverVel();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    int CartToJnt(const  ::JntArray&,const  ::FrameVel&, ::JntArrayVel&) SIP_OVERRIDE;
    int CartToJnt(const  ::JntArray&,const  ::Twist&, ::JntArray&) SIP_OVERRIDE;
    void updateInternalDataStructures() SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverVel(const sipChainIkSolverVel &);
    sipChainIkSolverVel &operator = (const sipChainIkSolverVel &);

    char sipPyMethods[3];
};

sipChainIkSolverVel::sipChainIkSolverVel():  ::ChainIkSolverVel(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel::sipChainIkSolverVel(const  ::ChainIkSolverVel& a0):  ::ChainIkSolverVel(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel::~sipChainIkSolverVel()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

int sipChainIkSolverVel::CartToJnt(const  ::JntArray& a0,const  ::FrameVel& a1, ::JntArrayVel& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_ChainIkSolverVel,sipName_CartToJnt);

    if (!sipMeth)
        return 0;

    extern int sipVH_PyKDL_7(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::FrameVel&, ::JntArrayVel&);

    return sipVH_PyKDL_7(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}

int sipChainIkSolverVel::CartToJnt(const  ::JntArray& a0,const  ::Twist& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,sipName_ChainIkSolverVel,sipName_CartToJnt);

    if (!sipMeth)
        return 0;

    extern int sipVH_PyKDL_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Twist&, ::JntArray&);

    return sipVH_PyKDL_6(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}

void sipChainIkSolverVel::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,sipName_ChainIkSolverVel,sipName_updateInternalDataStructures);

    if (!sipMeth)
        return;

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}


PyDoc_STRVAR(doc_ChainIkSolverVel_CartToJnt, "CartToJnt(self, q_in: JntArray, v_in: Twist, qdot_out: JntArray) -> int\n"
"CartToJnt(self, q_init: JntArray, v_in: FrameVel, q_out: JntArrayVel) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
        const  ::JntArray* a0;
        const  ::Twist* a1;
         ::JntArray* a2;
         ::ChainIkSolverVel *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_v_in,
            sipName_qdot_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverVel, &sipCpp, sipType_JntArray, &a0, sipType_Twist, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_ChainIkSolverVel, sipName_CartToJnt);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->CartToJnt(*a0,*a1,*a2);

            return SIPLong_FromLong(sipRes);
        }
    }

    {
        const  ::JntArray* a0;
        const  ::FrameVel* a1;
         ::JntArrayVel* a2;
         ::ChainIkSolverVel *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_init,
            sipName_v_in,
            sipName_q_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverVel, &sipCpp, sipType_JntArray, &a0, sipType_FrameVel, &a1, sipType_JntArrayVel, &a2))
        {
            int sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_ChainIkSolverVel, sipName_CartToJnt);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->CartToJnt(*a0,*a1,*a2);

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel, sipName_CartToJnt, doc_ChainIkSolverVel_CartToJnt);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverVel_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::ChainIkSolverVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel, &sipCpp))
        {
            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_ChainIkSolverVel, sipName_updateInternalDataStructures);
                return SIP_NULLPTR;
            }

            sipCpp->updateInternalDataStructures();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel, sipName_updateInternalDataStructures, doc_ChainIkSolverVel_updateInternalDataStructures);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverVel(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverVel(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverVel *sipCpp = reinterpret_cast< ::ChainIkSolverVel *>(sipCppV);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverVel(void *, int);}
static void release_ChainIkSolverVel(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverVel *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverVel *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverVel(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverVel(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverVel *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverVel(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverVel(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverVel(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverVel *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new sipChainIkSolverVel();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverVel* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_ChainIkSolverVel, &a0))
        {
            sipCpp = new sipChainIkSolverVel(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverVel[] = {{32, 255, 1}};


static PyMethodDef methods_ChainIkSolverVel[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), SIP_MLMETH_CAST(meth_ChainIkSolverVel_CartToJnt), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverVel_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverVel, "\1ChainIkSolverVel()\n"
"ChainIkSolverVel(ChainIkSolverVel)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverVel = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverVel,
        {SIP_NULLPTR},
        SIP_NULLPTR
    },
    {
        sipNameNr_ChainIkSolverVel,
        {0, 0, 1},
        2, methods_ChainIkSolverVel,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_ChainIkSolverVel,
    -1,
    -1,
    supers_ChainIkSolverVel,
    SIP_NULLPTR,
    init_type_ChainIkSolverVel,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_ChainIkSolverVel,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_ChainIkSolverVel,
    cast_ChainIkSolverVel,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 472 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolver.hpp>
using namespace KDL;
#line 1011 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"

#line 280 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 1016 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"
#line 201 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1022 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"


class sipChainIkSolverPos : public  ::ChainIkSolverPos
{
public:
    sipChainIkSolverPos();
    sipChainIkSolverPos(const  ::ChainIkSolverPos&);
    virtual ~sipChainIkSolverPos();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    int CartToJnt(const  ::JntArray&,const  ::Frame&, ::JntArray&) SIP_OVERRIDE;
    void updateInternalDataStructures() SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverPos(const sipChainIkSolverPos &);
    sipChainIkSolverPos &operator = (const sipChainIkSolverPos &);

    char sipPyMethods[2];
};

sipChainIkSolverPos::sipChainIkSolverPos():  ::ChainIkSolverPos(), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos::sipChainIkSolverPos(const  ::ChainIkSolverPos& a0):  ::ChainIkSolverPos(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos::~sipChainIkSolverPos()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

int sipChainIkSolverPos::CartToJnt(const  ::JntArray& a0,const  ::Frame& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_ChainIkSolverPos,sipName_CartToJnt);

    if (!sipMeth)
        return 0;

    extern int sipVH_PyKDL_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Frame&, ::JntArray&);

    return sipVH_PyKDL_5(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}

void sipChainIkSolverPos::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,sipName_ChainIkSolverPos,sipName_updateInternalDataStructures);

    if (!sipMeth)
        return;

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}


PyDoc_STRVAR(doc_ChainIkSolverPos_CartToJnt, "CartToJnt(self, q_init: JntArray, p_in: Frame, q_out: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverPos_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
        const  ::JntArray* a0;
        const  ::Frame* a1;
         ::JntArray* a2;
         ::ChainIkSolverPos *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_init,
            sipName_p_in,
            sipName_q_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverPos, &sipCpp, sipType_JntArray, &a0, sipType_Frame, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_ChainIkSolverPos, sipName_CartToJnt);
                return SIP_NULLPTR;
            }

            sipRes = sipCpp->CartToJnt(*a0,*a1,*a2);

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos, sipName_CartToJnt, doc_ChainIkSolverPos_CartToJnt);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_ChainIkSolverPos_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverPos_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::ChainIkSolverPos *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverPos, &sipCpp))
        {
            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_ChainIkSolverPos, sipName_updateInternalDataStructures);
                return SIP_NULLPTR;
            }

            sipCpp->updateInternalDataStructures();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos, sipName_updateInternalDataStructures, doc_ChainIkSolverPos_updateInternalDataStructures);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverPos(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverPos(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverPos *sipCpp = reinterpret_cast< ::ChainIkSolverPos *>(sipCppV);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverPos(void *, int);}
static void release_ChainIkSolverPos(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverPos *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverPos *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverPos(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverPos(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverPos *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverPos(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverPos(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverPos(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverPos *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            sipCpp = new sipChainIkSolverPos();

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverPos* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_ChainIkSolverPos, &a0))
        {
            sipCpp = new sipChainIkSolverPos(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverPos[] = {{32, 255, 1}};


static PyMethodDef methods_ChainIkSolverPos[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), SIP_MLMETH_CAST(meth_ChainIkSolverPos_CartToJnt), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverPos_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverPos, "\1ChainIkSolverPos()\n"
"ChainIkSolverPos(ChainIkSolverPos)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverPos = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_ABSTRACT|SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverPos,
        {SIP_NULLPTR},
        SIP_NULLPTR
    },
    {
        sipNameNr_ChainIkSolverPos,
        {0, 0, 1},
        2, methods_ChainIkSolverPos,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_ChainIkSolverPos,
    -1,
    -1,
    supers_ChainIkSolverPos,
    SIP_NULLPTR,
    init_type_ChainIkSolverPos,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_ChainIkSolverPos,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_ChainIkSolverPos,
    cast_ChainIkSolverPos,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 460 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainfksolvervel_recursive.hpp>
using namespace KDL;
#line 1311 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"

#line 241 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 1316 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"
#line 331 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarrayvel.hpp>
using namespace KDL;
#line 1320 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"
#line 159 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 1324 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"


class sipChainFkSolverVel_recursive : public  ::ChainFkSolverVel_recursive
{
public:
    sipChainFkSolverVel_recursive(const  ::Chain&);
    sipChainFkSolverVel_recursive(const  ::ChainFkSolverVel_recursive&);
    virtual ~sipChainFkSolverVel_recursive();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures() SIP_OVERRIDE;
    int JntToCart(const  ::JntArrayVel&, ::FrameVel&,int) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainFkSolverVel_recursive(const sipChainFkSolverVel_recursive &);
    sipChainFkSolverVel_recursive &operator = (const sipChainFkSolverVel_recursive &);

    char sipPyMethods[2];
};

sipChainFkSolverVel_recursive::sipChainFkSolverVel_recursive(const  ::Chain& a0):  ::ChainFkSolverVel_recursive(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainFkSolverVel_recursive::sipChainFkSolverVel_recursive(const  ::ChainFkSolverVel_recursive& a0):  ::ChainFkSolverVel_recursive(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainFkSolverVel_recursive::~sipChainFkSolverVel_recursive()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

void sipChainFkSolverVel_recursive::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainFkSolverVel_recursive::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainFkSolverVel_recursive::JntToCart(const  ::JntArrayVel& a0, ::FrameVel& a1,int a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_JntToCart);

    if (!sipMeth)
        return  ::ChainFkSolverVel_recursive::JntToCart(a0,a1,a2);

    extern int sipVH_PyKDL_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArrayVel&, ::FrameVel&,int);

    return sipVH_PyKDL_4(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainFkSolverVel_recursive_JntToCart, "JntToCart(self, q_in: JntArrayVel, out: FrameVel, segmentNr: int = -1) -> int");

extern "C" {static PyObject *meth_ChainFkSolverVel_recursive_JntToCart(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainFkSolverVel_recursive_JntToCart(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArrayVel* a0;
         ::FrameVel* a1;
        int a2 = -1;
         ::ChainFkSolverVel_recursive *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_out,
            sipName_segmentNr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9J9|i", &sipSelf, sipType_ChainFkSolverVel_recursive, &sipCpp, sipType_JntArrayVel, &a0, sipType_FrameVel, &a1, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainFkSolverVel_recursive::JntToCart(*a0,*a1,a2) : sipCpp->JntToCart(*a0,*a1,a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainFkSolverVel_recursive, sipName_JntToCart, doc_ChainFkSolverVel_recursive_JntToCart);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_ChainFkSolverVel_recursive_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainFkSolverVel_recursive_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainFkSolverVel_recursive_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainFkSolverVel_recursive *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainFkSolverVel_recursive, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainFkSolverVel_recursive::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainFkSolverVel_recursive, sipName_updateInternalDataStructures, doc_ChainFkSolverVel_recursive_updateInternalDataStructures);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainFkSolverVel_recursive(void *, const sipTypeDef *);}
static void *cast_ChainFkSolverVel_recursive(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainFkSolverVel_recursive *sipCpp = reinterpret_cast< ::ChainFkSolverVel_recursive *>(sipCppV);

    if (targetType == sipType_ChainFkSolverVel)
        return static_cast< ::ChainFkSolverVel *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainFkSolverVel_recursive(void *, int);}
static void release_ChainFkSolverVel_recursive(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainFkSolverVel_recursive *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainFkSolverVel_recursive *>(sipCppV);
}


extern "C" {static void dealloc_ChainFkSolverVel_recursive(sipSimpleWrapper *);}
static void dealloc_ChainFkSolverVel_recursive(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainFkSolverVel_recursive *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainFkSolverVel_recursive(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainFkSolverVel_recursive(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainFkSolverVel_recursive(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainFkSolverVel_recursive *sipCpp = SIP_NULLPTR;

    {
        const  ::Chain* a0;

        static const char *sipKwdList[] = {
            sipName_chain,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Chain, &a0))
        {
            sipCpp = new sipChainFkSolverVel_recursive(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainFkSolverVel_recursive* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_ChainFkSolverVel_recursive, &a0))
        {
            sipCpp = new sipChainFkSolverVel_recursive(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainFkSolverVel_recursive[] = {{4, 255, 1}};


static PyMethodDef methods_ChainFkSolverVel_recursive[] = {
    {SIP_MLNAME_CAST(sipName_JntToCart), SIP_MLMETH_CAST(meth_ChainFkSolverVel_recursive_JntToCart), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainFkSolverVel_recursive_JntToCart)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainFkSolverVel_recursive_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainFkSolverVel_recursive_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainFkSolverVel_recursive, "\1ChainFkSolverVel_recursive(chain: Chain)\n"
"ChainFkSolverVel_recursive(ChainFkSolverVel_recursive)");


sipClassTypeDef sipTypeDef_PyKDL_ChainFkSolverVel_recursive = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_CLASS,
        sipNameNr_ChainFkSolverVel_recursive,
        {SIP_NULLPTR},
        SIP_NULLPTR
    },
    {
        sipNameNr_ChainFkSolverVel_recursive,
        {0, 0, 1},
        2, methods_ChainFkSolverVel_recursive,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_ChainFkSolverVel_recursive,
    -1,
    -1,
    supers_ChainFkSolverVel_recursive,
    SIP_NULLPTR,
    init_type_ChainFkSolverVel_recursive,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_ChainFkSolverVel_recursive,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_ChainFkSolverVel_recursive,
    cast_ChainFkSolverVel_recursive,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 447 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainfksolverpos_recursive.hpp>
using namespace KDL;
#line 1613 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"

#line 241 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 1618 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"
#line 280 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 1622 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"
#line 201 "/home/songhat/catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1628 "/home/songhat/catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart3.cpp"


class sipChainFkSolverPos_recursive : public  ::ChainFkSolverPos_recursive
{
public:
    sipChainFkSolverPos_recursive(const  ::Chain&);
    sipChainFkSolverPos_recursive(const  ::ChainFkSolverPos_recursive&);
    virtual ~sipChainFkSolverPos_recursive();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures() SIP_OVERRIDE;
    int JntToCart(const  ::JntArray&, ::Frame&,int) SIP_OVERRIDE;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainFkSolverPos_recursive(const sipChainFkSolverPos_recursive &);
    sipChainFkSolverPos_recursive &operator = (const sipChainFkSolverPos_recursive &);

    char sipPyMethods[2];
};

sipChainFkSolverPos_recursive::sipChainFkSolverPos_recursive(const  ::Chain& a0):  ::ChainFkSolverPos_recursive(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainFkSolverPos_recursive::sipChainFkSolverPos_recursive(const  ::ChainFkSolverPos_recursive& a0):  ::ChainFkSolverPos_recursive(a0), sipPySelf(SIP_NULLPTR)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainFkSolverPos_recursive::~sipChainFkSolverPos_recursive()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

void sipChainFkSolverPos_recursive::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,SIP_NULLPTR,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainFkSolverPos_recursive::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainFkSolverPos_recursive::JntToCart(const  ::JntArray& a0, ::Frame& a1,int a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,SIP_NULLPTR,sipName_JntToCart);

    if (!sipMeth)
        return  ::ChainFkSolverPos_recursive::JntToCart(a0,a1,a2);

    extern int sipVH_PyKDL_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&, ::Frame&,int);

    return sipVH_PyKDL_3(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainFkSolverPos_recursive_JntToCart, "JntToCart(self, q_in: JntArray, p_out: Frame, segmentNr: int = -1) -> int");

extern "C" {static PyObject *meth_ChainFkSolverPos_recursive_JntToCart(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainFkSolverPos_recursive_JntToCart(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
         ::Frame* a1;
        int a2 = -1;
         ::ChainFkSolverPos_recursive *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_p_out,
            sipName_segmentNr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, SIP_NULLPTR, "BJ9J9|i", &sipSelf, sipType_ChainFkSolverPos_recursive, &sipCpp, sipType_JntArray, &a0, sipType_Frame, &a1, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainFkSolverPos_recursive::JntToCart(*a0,*a1,a2) : sipCpp->JntToCart(*a0,*a1,a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainFkSolverPos_recursive, sipName_JntToCart, doc_ChainFkSolverPos_recursive_JntToCart);

    return SIP_NULLPTR;
}


PyDoc_STRVAR(doc_ChainFkSolverPos_recursive_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainFkSolverPos_recursive_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainFkSolverPos_recursive_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainFkSolverPos_recursive *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainFkSolverPos_recursive, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainFkSolverPos_recursive::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainFkSolverPos_recursive, sipName_updateInternalDataStructures, doc_ChainFkSolverPos_recursive_updateInternalDataStructures);

    return SIP_NULLPTR;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainFkSolverPos_recursive(void *, const sipTypeDef *);}
static void *cast_ChainFkSolverPos_recursive(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainFkSolverPos_recursive *sipCpp = reinterpret_cast< ::ChainFkSolverPos_recursive *>(sipCppV);

    if (targetType == sipType_ChainFkSolverPos)
        return static_cast< ::ChainFkSolverPos *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainFkSolverPos_recursive(void *, int);}
static void release_ChainFkSolverPos_recursive(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainFkSolverPos_recursive *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainFkSolverPos_recursive *>(sipCppV);
}


extern "C" {static void dealloc_ChainFkSolverPos_recursive(sipSimpleWrapper *);}
static void dealloc_ChainFkSolverPos_recursive(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainFkSolverPos_recursive *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainFkSolverPos_recursive(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainFkSolverPos_recursive(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainFkSolverPos_recursive(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainFkSolverPos_recursive *sipCpp = SIP_NULLPTR;

    {
        const  ::Chain* a0;

        static const char *sipKwdList[] = {
            sipName_chain,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Chain, &a0))
        {
            sipCpp = new sipChainFkSolverPos_recursive(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainFkSolverPos_recursive* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_ChainFkSolverPos_recursive, &a0))
        {
            sipCpp = new sipChainFkSolverPos_recursive(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainFkSolverPos_recursive[] = {{2, 255, 1}};


static PyMethodDef methods_ChainFkSolverPos_recursive[] = {
    {SIP_MLNAME_CAST(sipName_JntToCart), SIP_MLMETH_CAST(meth_ChainFkSolverPos_recursive_JntToCart), METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainFkSolverPos_recursive_JntToCart)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainFkSolverPos_recursive_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainFkSolverPos_recursive_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainFkSolverPos_recursive, "\1ChainFkSolverPos_recursive(chain: Chain)\n"
"ChainFkSolverPos_recursive(ChainFkSolverPos_recursive)");


sipClassTypeDef sipTypeDef_PyKDL_ChainFkSolverPos_recursive = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_CLASS,
        sipNameNr_ChainFkSolverPos_recursive,
        {SIP_NULLPTR},
        SIP_NULLPTR
    },
    {
        sipNameNr_ChainFkSolverPos_recursive,
        {0, 0, 1},
        2, methods_ChainFkSolverPos_recursive,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    doc_ChainFkSolverPos_recursive,
    -1,
    -1,
    supers_ChainFkSolverPos_recursive,
    SIP_NULLPTR,
    init_type_ChainFkSolverPos_recursive,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_ChainFkSolverPos_recursive,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    release_ChainFkSolverPos_recursive,
    cast_ChainFkSolverPos_recursive,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};
